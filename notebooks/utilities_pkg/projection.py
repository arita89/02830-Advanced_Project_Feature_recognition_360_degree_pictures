# -*- coding: utf-8 -*-
"""Projection_draft.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LYKguFP_eX9PsWGXiBpa3leiU70cKdQQ
"""

import math, random
import os
from PIL import Image
from imageio import imread
from imageio import imwrite

"""
cwd = os.getcwd()  # Get the current working directory (cwd)
files = os.listdir(cwd)  # Get all the files in that directory
print("Files in %r: %s" % (cwd, files))
"""

def random_images_projections(file, PATHtoIMG, PATHout, extension_out = ".jpg",sizeout= 300, num_deformations = 3):
  imageInput = Image.open(PATHtoIMG)
  filename = os.path.dirname(PATHtoIMG)
  all_deformations = []
  imgxOutput = sizeout; imgyOutput = sizeout

  for i in range(num_deformations):
    pi2 = math.pi * 2
    # 3D Sphere Rotation Angles (arbitrary)
    xy = -pi2 * random.random()
    xz = -pi2 * random.random()
    yz = -pi2 * random.random()
    sxy = math.sin(xy); cxy = math.cos(xy)
    sxz = math.sin(xz); cxz = math.cos(xz)
    syz = math.sin(yz); cyz = math.cos(yz)
    (imgxInput, imgyInput) = imageInput.size
    pixelsInput = imageInput.load()
    imageOutput = Image.new("RGB", (imgxOutput, imgyOutput))
    pixelsOutput = imageOutput.load()
    # define a sphere behind the screen
    xc = (imgxOutput - 1.0) / 2
    yc = (imgyOutput - 1.0) / 2
    zc = min((imgxOutput - 1.0), (imgyOutput - 1.0)) / 2
    r = min((imgxOutput - 1.0), (imgyOutput - 1.0)) / 2
    # define eye point
    xo = (imgxOutput - 1.0) / 2
    yo = (imgyOutput - 1.0) / 2
    zo = -min((imgxOutput - 1.0), (imgyOutput - 1.0))
    xoc = xo - xc
    yoc = yo - yc
    zoc = zo - zc
    doc2 = xoc * xoc + yoc * yoc + zoc * zoc
    for yi in range(imgyOutput):
        for xi in range(imgxOutput):
            xio = xi - xo
            yio = yi - yo
            zio = 0.0 - zo
            dio = math.sqrt(xio * xio + yio * yio + zio * zio)
            xl = xio / dio
            yl = yio / dio
            zl = zio / dio
            dot = xl * xoc + yl * yoc + zl * zoc
            val = dot * dot - doc2 + r * r
            if val >= 0: # if there is line-sphere intersection
                if val == 0: # 1 intersection point
                    d = -dot
                else: # 2 intersection points => choose the closest
                    d = min(-dot + math.sqrt(val), -dot - math.sqrt(val))
                    xd = xo + xl * d
                    yd = yo + yl * d
                    zd = zo + zl * d
                    x = (xd - xc) / r
                    y = (yd - yc) / r
                    z = (zd - zc) / r
                    x0=x*cxy-y*sxy;y=x*sxy+y*cxy;x=x0 # xy-plane rotation
                    x0=x*cxz-z*sxz;z=x*sxz+z*cxz;x=x0 # xz-plane rotation 
                    y0=y*cyz-z*syz;z=y*syz+z*cyz;y=y0 # yz-plane rotation
                    lng = (math.atan2(y, x) + pi2) % pi2
                    lat = math.acos(z)
                    ix = int((imgxInput - 1) * lng / pi2 + 0.5)
                    iy = int((imgyInput - 1) * lat / math.pi + 0.5)
                    try:
                        pixelsOutput[xi, yi] = pixelsInput[ix, iy]
                    except:
                        pass
    #imageOutput.save("profile_projected.png", "PNG")
    #show image
    savepath_imageOutput = PATHout+'/'+str(file[0:-4])+"_def_%s"%i+ extension_out
    #savepath_imageOutput = str(filename[0:-4])+"deformed_%s"%i+ extension_out
    print (savepath_imageOutput)
    #print (type(imageOutput))
    imageOutput.save(savepath_imageOutput)
    all_deformations.append(imageOutput)
  return all_deformations

"""
# def image_projection(PATH):
# diplay examples
imageInput = Image.open("profile.jpg")
all_deformations = many_projections(imageInput, sizeout= 100, num_deformations = 30)

for image in all_deformations:
  #show image
  display(image)
"""